#!/bin/bash
# Pre-tool-use hook generated by Aircana
# This hook runs before any tool is executed

# Read JSON input from stdin
INPUT=$(cat)

# Parse JSON to extract tool information
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty')
TOOL_INPUT=$(echo "$INPUT" | jq -r '.tool_input // empty')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
CWD=$(echo "$INPUT" | jq -r '.cwd // empty')

# Log the tool usage (optional)
echo "$(date): Session $SESSION_ID - About to use tool: $TOOL_NAME in $CWD" >> ~/.aircana/hooks.log

# Basic validation example
case "$TOOL_NAME" in
  "Bash")
    # Add validation for bash commands
    COMMAND=$(echo "$TOOL_INPUT" | jq -r '.command // empty')
    if echo "$COMMAND" | grep -q "rm -rf /"; then
      cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Dangerous command detected: rm -rf /"
  },
  "continue": false,
  "stopReason": "Blocked dangerous command"
}
EOF
      exit 0
    fi
    ;;
  "Edit"|"Write")
    # Validate file operations
    FILE_PATH=$(echo "$TOOL_INPUT" | jq -r '.file_path // empty')
    # Add custom validation logic here
    # Example: Check if trying to modify system files
    if echo "$FILE_PATH" | grep -q "^/etc/\|^/usr/\|^/bin/\|^/sbin/"; then
      cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "ask",
    "permissionDecisionReason": "Attempting to modify system file: $FILE_PATH"
  },
  "continue": true,
  "systemMessage": "Warning: About to modify a system file"
}
EOF
      exit 0
    fi
    ;;
esac

# Allow the tool to proceed
cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow"
  },
  "continue": true
}
EOF